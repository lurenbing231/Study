## 单redis节点的分布式锁
```
set resource_name my_random_value NX PX 5000
```
##### resource_name 资源名称
##### my_random_value
客户端生成的随机字符串，保证所有客户端的所有获取锁的请求都是唯一的
##### NX
表示只有当资源对应的key值不存在的时候才能获取锁成功
##### PX 5000
表示这个锁5秒过期

### 无法解决的问题
当redis节点宕机时，客户端无法获取锁，服务不可用。  
平时操作：当master宕机时，slave升级为master，但是由于主从复制是异步的，存在延迟，可能导致客户端丧失锁。
## 分布式锁redlock
#### 步骤
1、获取当前时间（毫秒）  
2、按顺序依次向N个节点执行获取锁的操作。其中，存在一个获取锁的超时时间。当向一个节点获取锁失败后，会立即尝试下一个节点。  
3、计算获取锁消耗的时间，当前时间 - 第1步时间。  
获取锁成功条件：客户端从多于半数（大于N/2）个节点获取到锁，且获取锁消耗的时间没有超过锁有效时间。  
4、若获取锁成功，则锁有效时间重新计算，最初有效时间 - 获取锁消耗的时间  
5、若最终获取锁失败，客户端向所有节点发起释放锁的操作。

#### 问题1
当节点崩溃重启时，该机器的锁会清除，导致第二个客户端可能成功获取锁。  
例如：A、B、C、D、E五个节点，第一个客户端获取A、B、C三个节点的锁，C节点重启，第二个客户端可能获取C、D、E三个节点的锁，导致两个客户端同时获得了锁。  
解决办法：延迟重启，当节点崩溃后，先等待一段时间（大于锁的有效时间），然后重启

#### 问题2
当客户端1出现超时（GC、网络延迟等等），恢复过来后并不清楚redis锁已经过期，这时客户端2已经获取到锁并在操作，如果此时客户端1再进行操作，会造成冲突。  
解决方法：新增fencing token标记，客户端获取锁后，服务端返回此标记，当客户端1恢复后请求redis时会带上此标记，此时服务端可以根据此标记判断是否过期并拒绝请求。  
