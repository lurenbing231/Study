### 编程思想
   * [一、Java初始化](#一Java初始化)
       * [this关键字](#this关键字)
       * [初始化](#初始化)
       * [初始化顺序](#初始化顺序)
   * [二、类的复用](#二Java类的复用)
       * [复用类的初始化](#复用类的初始化)
   * [三、向上转型及final关键字](#三向上转型及final关键字)
       * [向上转型](#向上转型)
       * [final关键字](#final关键字)
   * [四、多态](#四多态)
   * [五、抽象类和接口](#五抽象类和接口)
   * [六、内部类](#六内部类)
   * [七、容器](#七容器)


## 一、Java初始化

Java通过构造器确保每个对象都被初始化，构造器采用与类相同的名称。
```
class Car {
   Car() {//无参构造器（默认构造器）
       System.out.println("Car");
   }

   Car(String name) {
       System.out.println("CarName:" + name);
   }
}
```
对于无参构造器在创建对象时：
```Car car = new Car();```
对于有形式参数的构造器，创建对象时：
```Car car = new Car("BMW");```
当Car(String)是Car类中唯一的构造器时，编译器将不会允许以其他任何方式创建Car对象-----Java编程思想（第四版）
如果类中没有构造器，编译器会自动创建一个默认构造区。但是如果定义了一个构造器（无论是否有参数），编译器都不会自动创建默认构造器。
构造器是没有返回值的，new表达式返回了对新建对象的引用，但构造器本身是没有任何返回值。
在Java中，可以用多种方式创建一个类，就像上面的代码一样，这里用到了方法重载，其规则是：每一个重载的方法必须都有一个独一无二的参数类型列表（其中无参和参数类型顺序也算）
对于基本类型能从一个“小”的类型自动提升至“大”的类型，在重载中也成立，下面是基本类型在重载中的情况。
```
public class Overload {//《Java编程思想》的例子
    void z1(char x) { System.out.print("z1(char) "); }
    void z1(byte x) { System.out.print("z1(byte) "); }
    void z1(short x) { System.out.print("z1(short) "); }
    void z1(int x) { System.out.print("z1(int) "); }
    void z1(long x) { System.out.print("z1(long) "); }
    void z1(float x) { System.out.print("z1(float) "); }
    void z1(double x) { System.out.print("z1(double) "); }

    void z2(byte x) { System.out.print("z2(byte) "); }
    void z2(short x) { System.out.print("z2(short) "); }
    void z2(int x) { System.out.print("z2(int) "); }
    void z2(long x) { System.out.print("z2(long) "); }
    void z2(float x) { System.out.print("z2(float) "); }
    void z2(double x) { System.out.print("z2(double) "); }

    void z3(short x) { System.out.print("z3(short) "); }
    void z3(int x) { System.out.print("z3(int) "); }
    void z3(long x) { System.out.print("z3(long) "); }
    void z3(float x) { System.out.print("z3(float) "); }
    void z3(double x) { System.out.print("z3(double) "); }

    void z4(int x) { System.out.print("z4(int) "); }
    void z4(long x) { System.out.print("z4(long) "); }
    void z4(float x) { System.out.print("z4(float) "); }
    void z4(double x) { System.out.print("z4(double) "); }

    void z5(long x) { System.out.print("z5(long) "); }
    void z5(float x) { System.out.print("z5(float) "); }
    void z5(double x) { System.out.print("z5(double) "); }

    void z6(float x) { System.out.print("z6(float) "); }
    void z6(double x) { System.out.print("z6(double) "); }

    void z7(double x) { System.out.print("z7(double) "); }

    @Test
    public void testOverload() {
        System.out.println("int:" );
        z1(5);
        z2(5);
        z3(5);
        z4(5);
        z5(5);
        z6(5);
        z7(5);
    }
}
```
其结果为：
<div align="center">
 <img src="图片/Java/初始化1.webp">
</div>
 
可以看出重载方法接受int型参数时，如果不存在int型形式参数类型时，实际数据类型会被提升。
因此，各个类型的提升顺序为：
char类型：char -> int -> long -> float -> double。
byte类型：byte -> short -> int -> long -> float -> double。
其他基本类型在提升时根据上面的顺序一样。

### this关键字
this关键字只能在方法内部使用，即在方法内部得到当前对象的引用。
```
class Car {
    Car getCar() {
        return this;
    }
}
```
返回Car对象的引用。
当一个类中存在多个构造器，并且想一个构造器调用另一个构造器时，this关键字可以发挥作用。在构造器中，如果this方法添加了参数列表，则是对符合此参数列表的某个构造器的明确调用。
```
class Car {
   Car() {
        this("BMW");//调用构造器Car(String name)
        System.out.println("Car");
   }
   Car(String name) {
        System.out.println("CarName:" + name);
   }
}
```
虽然可以调用其他构造器，但是不能同时调用两个，且this调用构造器必须在最起始的位置。

### 初始化
在Java中，编译器会尽可能保证所有变量在使用前都能得到恰当的初始化。
对于方法的局部变量来说，为保证初始化，对于使用时未初始化的变量，编译器会提示错误。
```
void z() {
   int i;
   i++;//Variable 'i' might not have been initialized
}
```
因此，对于局部变量来说，在使用前必须明确进行初始化。

对于类的数据成员（即字段）来说，编译器会对每一个数据成员提供一个初始值（自动进行初始化）。
```
public class InitialValues {
   boolean t;
   char c;
   byte b;
   short s;
   int i;
   long l;
   float f;
   double d;
   InitialValues initialValues;
   @Test
   public void test() {
      System.out.println("boolean: " + t);
      System.out.println("char: " + c);
      System.out.println("byte: " + b);
      System.out.println("short: " + s);
      System.out.println("int: " + i);
      System.out.println("long: " + l);
      System.out.println("float: " + f);
      System.out.println("double: " + d);
      System.out.println("initialValues: " + initialValues);
   }
}
```
结果如下图所示
 <div align="center">
 <img src="图片/Java/初始化2.png">
</div>
对于基本数据类型编译器保证有一个初始值（char的初始值为0，ASCII码值为0，对应的的是空字符），对于引用数据类型，初始值为null。并且，无法阻止自动初始化的进行，所有对于 int i = 7; i首先被置为0，然后变成7，对于所有基本类型和对象引用，这种情况都是成立的。

### 初始化顺序
对于静态数据，无论创建多少个对象，静态数据都只占用一份存储区域。
初始化顺序为：静态数据成员初始化（仅第一次执行）、非静态数据成员初始化、构造器、其他方法。
其中静态数据成员包括静态代码块
```
class Car {
   static String name;
   static {
        name = "BMW";
   }
}
```

## 二、类的复用
Java中复用类用两种方式：组合、继承

组合：组合只需将对象引用置于新类中。

```Car car = new Car();```

继承：Java中没有明确指出继承关系的类，都默认从标准根类Object进行继承。

```class BMWCar extends Car｛｝```

在继承中，子类可以访问父类public或protected修饰的方法。因此，一般规则是：所有的数据成员都指定为private，所有方法都指定为public。
```
public class Car {
    protected int i = 5;
    public void make() {
        System.out.println("制造汽车");
    }
}
```
```
public class BMWCar extends Car{
    protected int i = 9;
    public void make() {
        System.out.println("制造BMW汽车");
    }

    @Test
    public void test() {
        System.out.println(i);
        System.out.println(super.i);
        make();
        super.make();
    }
}
```
从例子中可以看出，当父类和子类有相同的方法和变量时，需要用super关键字来调用父类的方法和变量。

### 复用类的初始化

在初始化中，子类构造器在开始部分默认调用父类构造器。当我们想调用父类的带参构造器时，可以用super关键字。
```
public class Car {
    Car(Stringname){
       System.out.println("Car constructor");
    }
}
```
```
public class BMWCar extends Car{
    BMWCar(){
        super("BMW");
    }
}
```
如果父类只有带参构造器时，子类不进行明确调用父类构造器时，编译器会报错无法找到符合Car()形式的构造器。

如果在基类中存在被多次重载的方法名，那么在子类中重新定义该方法名并不会屏蔽掉基类中的任何版本，重载机制可以正常运行。
```
public class Car {
    public void make() {
        System.out.println("制造汽车");
    }
    public void make(String name) {
        System.out.println(name + "制造汽车");
    }
}
 ```
 ```
public class BMWCar extends Car{
    public void make(int i) {
        System.out.println("制造BMW汽车");
    }

    @Test
    public void test() {
        BMWCar bmwCar = new BMWCar();
        bmwCar.make(1);
        bmwCar.make();
        bmwCar.make("zl");
    }
}
```
如果不想这种事情发生（重载），想要重写，可以在方法前面加上@Override关键字，如果出现重载，编译器就会报错
<label style="color:red">Method does notoverride method from its superclass</lable>
```
@Override public void make(int i) {
    System.out.println("制造BMW汽车");
}
```

## 三、向上转型及final关键字

### 向上转型

继承技术最重要的方面是用来表现新类（导出类或子类）和基类（父类）之间的关系，即新类是基类的一种类型。

例如Car是一个基类，BMWCar是Car的导出类。
```
publicclass Car {
    public void make(){};
    static void create(Car car){
        car.make();
    }
}
```
```
publicclass BMWCar extends Car {
    public static void main(String[] args) {
        BMWCar bmwCar = new BMWCar();
        Car.create(bmwCar);
    }
}
```
从代码中可以看出，在create()中，程序代码可以对Car和它所有的导出类起作用，这种将BMWCar引用转换成Car引用的动作，称为向上转型。

### final关键字

  #### final数据

对于编译器来说，一个数据不可变可以减轻一些运行时的负担。在Java中，这类常量必须是基本数据类型，并且以关键字final表示，对这个常量定义时，必须对其进行赋值。

一个既是final又是static的域只占据一段不能改变的存储空间。——《JAVA编程思想》（第四版）

对于对象引用，final使引用恒定不变。一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象，但是对象其自身可以被修改，Java未提供使任何对象恒定不变的途径。

  #### 空白final
```
publicclass BlankFinal {
    private final int i = 0;
    private final int j;

    public BlankFinal() {
        j = 1;
    }
}
```
其中j为空白final。对于final修饰的数据来说，必须在定义处或者在每个构造器中用表达式对数据进行赋值。

  #### final参数

在Java中，参数列表中以声明的方式将参数指明为final，意味着无法在方法中更改参数引用所指向的对象。

  #### final方法

把方法锁定，以防任何继承类修改它的含义。即确保在继承中方法行为保持不变，并且不会被覆盖。

在Java SE4及以前可以提升效率，之后版本final方法只明确表示禁止覆盖。

  #### final和private关键字

类中所有private方法都隐式地指定为final的。因为基类中private方法不属于接口的一部分，无法被覆盖。

  #### final类

当类定义为final时，表明不打算继承该类。即该类不希望有任何子类（导出类）。

final类无法被继承，因此类中所有方法都隐式的指定为final。

## 四、多态
多态也可以叫做后期绑定（动态绑定或运行时绑定）。即编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体，并加以调用。Java中除了static方法和final方法（private方法属于final方法）之外，其他所有方法都是后期绑定。

只有普通的方法调用可以用多态，如果直接访问某个域，这个访问会在编译期进行解析。
```
class Car {
    public int id = 0;

    public int getId() {
        return id;
    }
}

class BMWCar extends Car {
    public int id = 1;

    public int getId() {
        return id;
    }

    public int getSuperId() {
        return super.id;
    }
}

public class FieldAccess {
    public static void main(String[] args) {
        Car car = new BMWCar();
        System.out.println("car.id=" + car.id + " " + "car.getId()=" + car.getId());
        BMWCar bmwCar = new BMWCar();
        System.out.println("bmwCar.id=" + bmwCar.id + " "
                + "bmwCar.getId()=" + bmwCar.getId() + " "
                + "bmwCar.getSuperId()=" + bmwCar.getSuperId());
    }
}
```
结果为：
<div align="center">
 <img src="图片/Java/多态1.webp">
</div>

当BMWCar对象转型为Car对象时，任何域访问操作都将有编译器解析，因此不是多态。在本例中，为Car.id和BMWCar.id分配了不同的存储空间，BMWCar实际上包含了两个称为id的域：它自己的和它从Car处得到的。因此引用Car时产生的默认域为0；引用BMWCar时产生的默认域为1，引用BMWCar（导出类）时想要访问父类的域必须显式的指明super.id。

**向下转型与运行时类型识别**

对于向上转型是安全的，因为基类不会具有大于导出类的接口。但是对于向下转型，并不是安全的。如我们无法知道一个“车”它确实是一个“BMW”，它也可以是一个“BYD”或其它一些类型。要解决这个问题，必须有某种方法来确保向下转型的正确性。

在Java中，所有转型都会得到检查！进入运行期时仍然会进行检查，以便确保其的确是我们希望的那种类型。如果不是，会返回一个ClassCastException（类转型异常）。这种在运行期间对类型进行检查的行为称作“运行时类型识别”（RTTI）。
```
class Useful{
    public void f(){};
}
class MoreUseful extends Useful{
    public void f(){};
    public void g(){};
}
public class RTTI {
    public static void main(String[] args){
        Useful[] x = {new Useful(), new MoreUseful()};
        x[0].f();
        x[1].f();
        //x[1].g();//Cannot resolve method 'g()'
        ((MoreUseful)x[1]).g();//Dowcast/RTTI
        ((MoreUseful)x[0]).g();//Exception thrown
    }
}
```
结果为：
<div align="center">
 <img src="图片/Java/多态2.webp">
</div>
