#### jvm虚拟机内存结构
##### 程序计数器
线程私有。当前线程所执行的字节码的行号指示器。
##### 本地方法栈
线程私有。为虚拟机使用Native方法服务。
##### 虚拟机栈
线程私有。存储局部变量表、操作栈、动态链接、方法出口、对象指针。
##### 方法区
线程共享。每个线程有一个私有的栈，每个线程中方法的调用会在栈中创建一个栈帧。存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。
##### 堆
线程共享。所有对象实例和数组都在堆上。回收器主要管理的对象。
#### 控制参数
##### 堆
-Xms 设置堆最小空间  
-Xmx 设置堆最大空间  
-Xmn 设置新生代大小（官方推荐整个堆的3/8）  
-XX:NewRatio 年轻代与年老代的比值  
-XX:SurvivorRatio Eden区与Survivor区的比值  
##### 方法区
-XX:PermSize 设置最小空间
-XX:MaxPermSize 设置最大空间
#### 对象存活算法
##### 引用计数算法
给对象添加一个引用计数器，每当一个地方应用时，计数器+1，引用失效时，计数器-1。  
优点：实现简单，判定效率高  
缺点：无法解决对象之间相互引用问题
##### 可达性分析算法
通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径（引用链），当一个对象到GCRoots没有引用链时，证明此对象不可用。  
java中，可作为GCRoot的对象有：  
1、虚拟机栈中引用的对象  
2、方法区中静态属性引用的对象  
3、方法区中常量引用的对象  
4、本地方法中JNI引用的对象
###### 两次标记
1、对象可达性分析后，没有与GCRoots相连接，被第一次标记并筛选  
2、对象没有覆盖finalize()方法，或者finalize()方法已经被调用过，此时对象被标记
#### 新生代->老生代的条件
1、minor gc后，存活在survior区域的对象的age会+1，当超过（默认）15的时候，转移到老年代  
2、survior空间中相同年龄的对象大小大于survivor空间一半时，年龄大于等于该年龄的对象直接进入老年代
#### 垃圾回收算法
##### 标记清除法
1、通过GC Roots标记所有可达对象  
2、清除所有未标记的对象
##### 复制算法
将原有的内存空间分为两块，每次只使用一块。垃圾回收时，将正在使用的内存中存活对象复制到未使用的内存块，然后清除使用的内存块中所有的对象
##### 标记压缩算法
#### 垃圾收集器
##### 新生代GC
串行GC（Serial）复制算法，串行。  
并行GC（ParNew）复制算法，并行。  
并行回收GC（Parallel Scavenge）复制算法，并行，目标：达到一个可控制的吞吐量：应用程序运行时间/（应用程序运行时间+GC时间），适用后台持久运行的应用程序，不适用交互较多的应用程序。可以自适应的调节参数（新生代大小、Eden和Survivor的比例、晋升老年代的年龄等）。
##### 老生代GC
串行GC（Serial Old）标记整理算法，串行  
并行GC（Parallel Old）标记整理算法，并行  
并发GC（CMS）获取最短回收停顿时间为目标的收集器，标记清除算法  
#### CMS收集器
###### CMS步骤
初始标记：只标记GC Roots直接关联的对象  
并发标记：标记所有对象  
重新标记：修正并发标记中因用户运作导致标记产生变动的对象  
并发清除
###### CMS优点
并发收集、低停顿
###### CMS缺点
1、对CPU资源敏感，CMS默认线程数是（CPU数量+3）/4，当CPU资源大于4时，占用不少于25%的CPU，当不足4个时，占用了50%，会导致应用程序变慢  
2、无法处理浮动垃圾。在并发标记时，应用程序产生的垃圾，因为在本次无法被标记，因此要等到下次GC，导致CMS算法要预留一部分空间  
3、采用标记清除算法，会导致出现空间碎片产生
##### G1收集器
###### 特点
并行与并发。能充分利用CPU，缩短停顿时间。  
分代收集。  
空间整合。采用标记整理算法，不会产出内存空间碎片。  
可预测的停顿。建立预测停顿的时间模型，有计划的避免在整个Java堆中进行全区域的垃圾收集，通过维护优先列表的方式，优先回收价值最大的区域。
横跨整个堆内存。将整个对内存划分为多个**大小相等**的独立区域（Region），新生代和老年代只是这些不连续区域的集合。  
维护一个Remembered Set，不同的区域会有引用，会把引用信息记录到**被引用对象所属的区域的Remembered Set**中。
###### 步骤
初始标记：标记GC Roots直接关联的对象，并修改TAMS（Nest Top Mark Start）的值，让下一个阶段并发标记时，应用程序在正确的区域中创建对象。  
并发标记：同CMS
最终标记：修正并发标记中变动的对象。虚拟机会把这段时间对象的变动记录在线程的Remembered Set Logs里面，在最终标记时把Remembered Set Logs数据合并到Remembered Set中，可以多线程**并行**执行。  
筛选回收：对各个区域回收价值和成本进行排序，根据用户期望的回收时间制定回收计划。与用户线程并发执行。
#### 问题定位
###### 常规定义
Minor GC：年轻代垃圾回收  
Major GC：老年代垃圾回收  
Full GC：整个堆空间垃圾回收
##### cpu飙升
1、查询最耗CPU的进程
```
top
```
2、查找该进程下最耗费CPU的线程
```
top -Hp pid
```
3、转换进制
```
printf "%x\n" pid
```
4、过滤指定线程，打印堆栈信息
```
jstack pid | grep '转换后16进制' -C5 --color
```
##### 线程死锁
1、查找java进程id
```
jps 或者 ps aux | grep '程序名'
```
2、查看java进程的线程快照信息
```
jstack -l pid
```
##### OOM内存泄漏
###### 三种情况
1、内存过小，不够用  
2、申请资源太多，没有释放。GC等  
3、申请资源太多，资源耗尽。线程过多、线程内存过大等
###### 排查
1、排查申请内存过小  
查询新生代、老年代内存分配大小以及使用情况
```
jmap -heap pid
```
2、排查gc  
查询各个代内存情况
```
jstat -gcutil [pid] [time]
```
3、查找最费内存的对象
```
jmap -histo:live pid | more
```
注意事项：该命令会造成jvm强制执行一次fgc，推荐采用dump内存快照，用jvisualvm分析  
4、确认资源是否耗尽  
```
pstree  查看进程线程数量
netstat 查看网络连接数量
```
#### 调优流程
##### 调优原则
```
1、MinorGC回收原则：每次Minor GC都尽可能多的收集垃圾对象。减少发生Full GC的频率
2、GC内存最大化原则：垃圾收集器能使用的内存越大，垃圾收集效果越好，应用程序越流畅
3、3选2原则：在性能属性方面，吞吐量、延迟、内存占用，只能选择其中两个进行调优
```
##### 步骤
初始设置：活跃数据的大小m（多次Full GC后取平均值）  
通常：总大小 = 3 or 4 * m，新生代 = 1.5 * m，老年代 = 总大小 - 新生代
###### 确定目标
明确应用程序系统需求(高吞吐、高可用、低延迟)  
```
受GC影响请求占比=（接口相应时间 + GC时间） * N / T
N为单位时间T内GC次数
```
###### 目标一：Major GC和Minor GC频繁
降低TP90、TP99时间。  
* 优化  
```
1、Minor GC频繁，通常是由于新生代空间较小导致，适当增加新生代空间。对于虚拟机来说复制对象成本高于扫描成本，Minor GC时间取决于GC后存活对象的数量，不是Eden区的大小。
2、Major GC频繁，调整新声代判断年龄，减少对象进入老年代的。
```
* 总结
```
1、应用存在大量的短期对象，应该选择较大的年轻代
2、存在较多的持久对象，老年代适当增大
```
###### 目标二：请求高峰期放生GC，导致服务可用性下降
降低重标记（Remark）时间
* 优化
```
1、重标记阶段要扫描整个堆。原因：在并发标记时，会有一些老年代的对象被新生代对象引用。
2、在Remark前增加可中断的并发预清理，该阶段在并发标记过程中，当Eden使用超过阈值（默认2M）时，将执行Minor GC，这使重标记阶段对象变少了。同时提供超时等待（默认5s）和强制Minor GC
.
```
* 总结
```
1、因为跨代引用的存在，CMS算法在重标记阶段必须扫描整个堆。为了减少新生代对象，增加了可中断的预清理阶段和强制Minor GC参数
2、新生代对象也会被老年代引用，jvm引入卡表（card table）。
卡表：将老年代分成若干个512B的卡（card）。卡表是单字节数组，数组中每个元素对应着一张卡，当有老年代引用新生代时，卡表元素设置适当的值，这样可以找到老年代中有哪些卡里有指向新生代的引用，避免全堆扫描。
卡表第二个作用：标记并发标记阶段哪些卡被修改过，重新标记时，避免全堆扫描
```
###### 目标三：发生Stop-The-World的GC
* 原因
```
1、元空间不足
2、CMS GC时出现promotion failed（晋升失败）和concurrent mode failure（老年代空间不足，终止CMS，直接进行Serial Old GC）
3、年轻代晋升到老年代的平均大小大于老年代剩余空间
4、主动触发Full GC来避免碎片问题
```
* 总结
```
内存自动扩容和收缩会带来性能损耗，推荐Xms和Xmx设置成相同的
```
